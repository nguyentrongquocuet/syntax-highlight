import { LRLanguage, foldNodeProp, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@codemirror/highlight';
import { LRParser } from '@lezer/lr';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,given:42, and:50, or:50, not:50, is:50, when:52, end:54};
const parser = LRParser.deserialize({
  version: 13,
  states: "&YQQOPOOOOOO'#C_'#C_O`OPO'#C^OOOO'#Cc'#CcOeOPO'#CaOOOO'#Cf'#CfOjOPO'#CeOOOO'#Cd'#CdOOOO'#Cp'#CpOOOO'#Cj'#CjQQOPOOOuOPO,58xO!ZOPO,58{OOOO'#Cm'#CmO!`OPO,59PO!hOPO'#CxO!cOPO,59TOOOO-E6h-E6hO!pOPO'#CsOOOO1G.d1G.dO#XOPO1G.gOOOO-E6k-E6kOOOO'#Ch'#ChOOOO1G.k1G.kO#^OPO'#CnO#cOPO,59dOOOO1G.o1G.oOOOO'#Ck'#CkO$POPO,59_O$WOPO'#ClO#kOPO,59_O$]OPO7+$ROOOO,59Y,59YOOOO-E6l-E6lOOOO-E6i-E6iO$bOPO1G.yO$vOPO,59WOOOO-E6j-E6jOOOO<<Gm<<GmO%_OPO1G.r",
  stateData: "%v~OUSOePOiROjTO~OfZO~Of[O~OUSOZ]OklP~OSbOUgPcgPegPigPjgP~OiRO~OZ]OkfO~OZhOklX~OfkOhmOUgXcgXegXigXjgX~OfoO~OUSO~OZhOkla~OhmOUgacgaegaigajga~OfkO~P#kOStO~OUvO~OhmOUgicgiegiigijgi~OfkOU`ac`ae`ah`ai`aj`a~OfkOU`ic`ie`ih`ii`ij`i~O",
  goto: "#imPPnrPvP!Qn!X!]P!a!X!g!m!w#R#XP#_PP#cPPPP#fTWOYTQOYSWOYQ_URphSWOYRd[TVOYTUOYQg^Rj`QYORaYQlbSrlwRwtQnbQslTunsQ^URe^Qi_RqiTXOYRcZR`U",
  nodeNames: "âš  Program GivenExpression Given Identifier DecContent Word BinaryCompare ConDec ConDec1 StartDec NewLine EndDec ConDec2",
  maxTerm: 28,
  skippedNodes: [0],
  repeatNodeCount: 5,
  tokenData: "!j~RYXYqYZv]^qpqq|}}}!O!S!Q![!S!c!}!S#R#S!S#T#o!S~vOf~~}OZ~f~~!SOh~~!ZTS~U~}!O!S!Q![!S!c!}!S#R#S!S#T#o!S",
  tokenizers: [0],
  topRules: {"Program":[0,1]},
  specialized: [{term: 4, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});

const EXAMPLELanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            foldNodeProp.add({
                ConDec(node, state) {
                    return {
                        from: node.from + 4,
                        to: node.to,
                    };
                },
                GivenExpression(node) {
                    return null;
                }
            }),
            styleTags({
                Identifier: tags.integer,
                LineComment: tags.lineComment,
                BinaryCompare: tags.keyword,
                'ConDec1/BinaryCompare': tags.keyword,
                'ConDec2/BinaryCompare': tags.keyword,
                'ConDec1/StartDec': tags.keyword,
                'ConDec1/EndDec': tags.keyword,
                'ConDec2/StartDec': tags.keyword,
                'ConDec2/EndDec': tags.keyword,
                'GivenExpression/Given': tags.keyword,
            }),
        ]
    }),
    languageData: {
        commentTokens: { line: "!" },
    }
});
const FlexruleLang = new LanguageSupport(EXAMPLELanguage);

export { EXAMPLELanguage, FlexruleLang };
